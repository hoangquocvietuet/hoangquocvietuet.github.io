---
layout: post
published: true
title: deptrai2k7 03
date: 2022/09/14
tags: [CP]
---

## TOY

#### subtask 1:

Duyệt qua các hoán vị của dãy $$a$$.

ĐPT: $$O(n!)$$.

#### subtask 2:

Gọi $$dp[mask]$$ là đáp án nếu ta dùng các số thuộc tập $$mask$$. Khi thêm số $$i$$ không thuộc tập mask, ta biết được $$S$$ tăng lên bao nhiêu để cập nhật $$dp$$.

ĐPT: $$O(2^n \times n)$$.

#### subtask 3:

Nhận thấy dãy tối ưu $$S = ax + ax + .. + bx + bx + .. + cx + cx + .. + x + x + .. + 1 + 1 + ..$$ và $$c \mid b \mid a$$.

Gọi $$dp[i]$$ là đáp số nếu ta coi $$i$$ đóng vai trò là $$x$$ theo nhận xét trên. Gọi $$cnt[i]$$ là các số là bội của $$i$$. Khởi tạo $$dp[i] = cnt \times i$$. Ta chọn ra $$j \mod i = 0$$ đóng vai trò là $$cx$$ theo nhận xét trên để tối ưu $$dp$$.

$$dp[i] = max(dp[i], dp[j] + (cnt[i] - cnt[j]) \times i)$$.

Lưu ý các số $$1$$ đằng sau.

ĐPT: $$O(a^2)$$.
 
#### subtask 4:

Tính nhanh mảng $$cnt[i]$$ và $$dp[i]$$ bằng for $$i, 2 \times i, 3 \times i, ..$$.

ĐPT: $$O(a \log a)$$.

#### subtask 5:

Nhận xét: chỉ quan tâm các $$j$$ sao cho $$\frac{j}{i}$$ là số nguyên tố.

ĐPT: $$O(a \log\log(a))$$.

[code](https://ideone.com/vawCoS).

## SORTSTR

#### subtask 1:

Dùng hàm `std::sort`.

ĐPT: $$O(q \times n \times \log(n))$$.

#### subtask 2:

Giả sử kí tự một nhỏ hơn kí tự hai theo thứ tự từ điển.

Gọi số lượng kí tự một trong đoạn $$[l, r]$$ là $$a$$, số lượng kí tự hai là $$(r - l + 1) - a$$.

Nếu $$t_i = 1$$, ta xếp $$a$$ kí tự một và $$(r - l + 1) - a$$ kí tự hai.

Nếu $$t_i = 2$$, ta xếp $$(r - l + 1) - a$$ kí tự hai rồi đến $$a$$ kí tự một.

Do đó ta chỉ cần dùng một segment tree quản lí số lượng kí tự một trong đoạn.

ĐPT: $$O(q \times \log(n))$$.

#### subtask 3:

Dùng $$26$$ segtree để quản lí.

ĐPT: $$O(q \times \log(n) \times 26)$$.

## FRIEND

#### subtask 1:

Dãy các sự kiện sẽ có dạng
`1 1 2 2 1 1 1 1 2 2 2..`

Nhận xét: trong những sự kiện $$1$$ liên tiếp, ta chỉ cần quan tâm sự kiện cuối cùng.

Ta có thể for thứ tự ưu tiên (là một hoán vị của $$1..m$$) và tìm ra số người bạn lớn nhất có thể vui. Sau đó chọn thứ tự ưu tiên có kết quả lớn nhất.

[code](https://ideone.com/gjjTN5).

ĐPT: $$O(m! \times n)$$.

#### subtask 2:

Nhận xét: Những sự kiện $$2$$ liên tiếp, chỉ có tối đa một người bạn có thể vui.

Ta chuẩn bị mảng $$ban[i][j] = false$$ nếu $$i$$ và $$j$$ cùng nhóm sự kiện $$2$$ liên tiếp.

Sau đó ta for tất cả tập hợp và kiểm tra có thoả mãn hay không.

ĐPT: $$O(2^m \times m^2)$$.

#### subtask 3:

Gọi $$dp[mask]$$ là đáp số nếu xét tất cả các người trong tập $$mask$$.

Xét bit lớn nhất của $$mask$$ là $$u$$:
- Nếu ta giữ lại $$u$$ thì không được giữ những thằng $$v$$ thoả mãn $$ban[u][v] = false$$. 
- Nếu ta không giữ lại $$u$$ thì ta được tập hợp $$mask \oplus u$$.

Vì có tối đa $$2^{40}$$ khả năng nên ta không thể dùng lưu vào mảng $$dp$$ như bình thường. 

Tối ưu bằng [meet in the middle](https://usaco.guide/gold/meet-in-the-middle?lang=cpp).

Ý tưởng chung: Nếu $$mask$$ có ít hơn $$20$$ bit, ta lưu vào mảng $$dp$$. Ngược lại có tối đa $$2^{20}$$ khả năng của các bit lớn hơn $$20$$.

[code của một idol giấu tên](https://ideone.com/uvfyQ2).

