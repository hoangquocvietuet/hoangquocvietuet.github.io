---
layout: post
published: true
title: deptrai2k7 01
date: 2022/09/11
tags: [CP]
---

## WEDDING

#### subtask 1:

Ta luôn chắc rằng, những bàn thừa cốc sẽ mang tới những bàn thiếu cốc. Bên cạnh đó, việc xuất phát từ bàn nào cũng không ảnh hưởng kết quả. Do đó ta có thể duyệt những bàn thừa cốc và duyệt những bàn thiếu cốc gần nhất theo chiều di chuyển để mô phỏng quá trình. Ngoài ra, thay vì mang mỗi lượt một chiếc cốc thì ta coi như mang nhiều chiếc cốc một lượt.

ĐPT: $$O(n^2)$$.

#### subtask 2:

Nếu ta cần di chuyển từ $$i$$ sang $$j$$ $$(i < j)$$ thì ta có thể di chuyển đến $$i + 1$$, sau đó lại mô phỏng quá trình di chuyển $$i + 1$$ sang $$j$$. Do đó ta giảm được đáng kể bước chuyển trạng thái tham lam.

Thực tế, ta chỉ cần duyệt tối đa hai lần vì mảng xếp theo hình tròn.

ĐPT: $$O(n)$$.

## KEYLOGGER

#### subtask 1:

Gọi $$dp[i][j]$$ là số mật khẩu nếu chỉ xét $$i$$ phần tử đầu của mảng $$P$$ và kí tự gõ cuối cùng là $$j$$. Ta có bước chuyển trạng thái $$dp[i + 1][h]$$ += $$dp[i][j]$$ với $$h$$ thoả mãn $$T[j][h] - L \le P_i \le T[j][h] + L$$.

ĐPT: $$O(n \times k^2)$$.

#### subtask 2:

Ta nhận thấy vì mảng $$T[j]$$ không giảm nên tất cả $$h$$ thoả mãn nằm liên tiếp nhau. Do vậy ta có dùng chặt nhị phân để tìm kiếm hai chỉ số $$h'$$ và $$h''$$. Sau đó ta dùng trick mảng cộng dồn để tăng $$dp$$ đoạn $$[h', h]$$ lên.

ĐPT: $$O(n \times k \times \log(k))$$.

#### subtask 3:

Bước $$dp$$ không thể tối ưu hơn, do đó ta nghĩ đến việc tối ưu bước tìm kiếm $$h'$$ và $$h''$$. Nếu mảng $$P$$ được sắp xếp tăng dần thì ta có thể dùng hai con trỏ thay vì nhặt nhị phân (xử lí offline trước).

ĐPT: $$O(n \times k + n \times \log(n)$$.

[code](https://ideone.com/p5Gonv).

## PARTITION

Editorial chỉ đưa ra lời giải cách tìm giá trị nhỏ nhất. Chi phí lớn nhất tương tự.

#### subtask 1:

Ta duyệt nhị phân để chia đoạn và lấy min các cách.

ĐPT: $$O(2^n)$$.

#### subtask 2:

Gọi $$dp[i][j]$$ là giá trị nhỏ nhất của một cách chia $$i$$ phần tử đầu ra làm $$j$$ đoạn. Công thức:

$$dp[i][j] = min(dp[h - 1][j - 1] + max(a_h, ..., a_i))$$ với $$1 \le h \le i$$.

ĐPT: $$O(n^3)$$.

#### subtask 3:

Nhìn vào công thức, ta có hai trường hợp: $$a_i$$ là max của đoạn và $$a_i$$ không phải max của đoạn.

Trường hợp $$a_i$$ là max của đoạn $$[h, i]$$. Vậy $$dp[i][j] = min(dp[u - 1][j - 1]) + a[i]$$ với $$h \le u \le i$$. 

Ta có thể chuẩn bị trước để tìm $$min(dp[u - 1][j - 1])$$ bằng `sparse table`.

Trường hợp $$a_i$$ không là max của đoạn. Vậy $$dp[i][j] = dp[h - 1][j]$$. 

ĐPT: $$O(n^2 \times \log(n))$$.

#### subtask 4:

Thay vì chặt nhị phân tìm $$h$$, ta lưu một stack với ý nghĩa $$a[st[i]]$$ là max trong đoạn $$[st[i - 1] + 1, st[i]]$$. Bên cạnh đó, ta cũng duy trì được $$min(dp[u - 1][j - 1]$$ khi pop phần tử ra.

ĐPT: $$O(n^2)$$.

#### subtask 5:

Thời gian chạy của subtask 4 đã đủ qua TL nhưng bộ nhớ vẫn quá lớn. Ta nhận thấy $$dp[i][j]$$ chỉ xét từ $$dp[h][j - 1]$$ hoặc $$dp[h][j]$$ nào đó. Do vậy ta duyệt chiều số phần tử trước để giảm bộ nhớ.

[code](https://ideone.com/5Iwtz6).