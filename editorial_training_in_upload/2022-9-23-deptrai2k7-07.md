---
layout: post
published: true
title: deptrai2k7 07
date: 2022/09/23
tags: [CP]
---

## Quản lí công ty

#### subtask 1:

Có $$\frac{n \times (n - 1)}{2}$$ cạnh có thể tạo ra. Ta duyệt khả năng chọn $$n - 1$$ cạnh và kiểm tra.

ĐPT: $$O(\binom{\frac{n \times (n - 1)}{2}}{n - 1} \times n^2)$$.

#### subtask 2:

Ta nhận thấy ta có thể tạo ra cây thoả mãn từ một đoạn $$[l, r]$$ liên tiếp. Nếu ta chọn một đỉnh $$l \le i \le r$$ làm gốc của cây, thì cây con bên trái sẽ tạo được từ đoạn $$[l, i - 1]$$, cây con phải sẽ tạo ra được từ đoạn $$[i + 1, r]$$. 

Giả sử ta có cạnh nối tới cây con trái. Giá trị đóng góp vào kết quả là tổng $$c[u][v]$$ với $$u$$ thuộc đoạn $$[l, i - 1]$$ và $$v$$ không thuộc đoạn $$[l, i - 1]$$. Tương tự với cây con phải.

Việc duy trì tổng có thể làm song song khi chọn $$i$$. Tuỳ cách cài đặt mà đpt có thể là $$O(n^4)$$ hoặc $$O(n^3)$$.

#### subtask 3:

Có thể tính tổng trên bằng tổng tiền tố. 

[code](https://ideone.com/N4N8bj).

ĐPT: $$O(n^3)$$.

## Xâu con chung độc nhất

Đây là một bài tương đối dễ nhưng khá bất ngờ vì điểm mọi người cực thấp.

#### subtask 1:

Ta duyệt một xâu con của $$s$$ và kiểm tra số lượng xâu con đó trong $$s$$ và $$t$$.

ĐPT: $$O(n^4)$$.

#### subtask 2:

Có thể dùng hash để cải tiến subtask 1.

ĐPT: $$O(n^3)$$.

#### subtask 3:

Ta lưu hash vào `std::map`.

ĐPT: $$O(n^2 \log(n))$$.

#### subtask 4:

Ta chuẩn bị mảng $$f[i][j]$$ là dãy con chung dài nhất bắt đầu tại $$i$$ và $$j$$ của xâu $$s$$. $$g[i][j]$$ với ý nghĩa tương tự ở xâu $$t$$. 

Nếu ta có $$f[i][j] = x$$, ta chỉ được phép xét xâu con có độ dài lớn hơn hoặc bằng $$x + 1$$ bắt đầu tại $$i$$ của xâu $$s$$ (nếu độ dài ngắn hơn, nó sẽ xuất hiện nhiều hơn một lần). Ta lưu lại thông tin này vào mảng $$p[i]$$ cho xâu $$s$$ và $$q[i]$$ cho xâu $$t$$.

Lúc này ta đã có đủ thông tin để làm quy hoạch động. Gọi $$dp[i][j]$$ là đáp án nếu xét hai xâu con bắt đầu tại $$i$$ trên xâu $$s$$ và bắt đầu tại $$j$$ trên xâu $$t$$. Nếu $$s[i] \neq t[j]$$, ta cho $$dp[i][j] = 0$$. Ngược lại nếu $$s[i] = t[j]$$, có thể chắc rằng $$dp[i][j] = dp[i + 1][j + 1] + 1$$. Nhưng ta chỉ lấy kết quả $$dp$$ này nếu như thoả mãn thông tin $$p[i]$$ và $$q[j]$$.

[code](https://ideone.com/gfAUp4).

ĐPT: $$O(n^2)$$.

## Con đặc biệt

#### subtask 1:

Tạo mảng $$cnt$$ như đề bài.

ĐPT: $$O(n^2)$$.

#### subtask 2:

Dễ thấy đáp án là độ sâu của node.

ĐPT: $$O(n)$$.

#### subtask 3:

Hãy chắc chắn rằng bạn biết đến [dsu on tree](https://codeforces.com/blog/entry/44351). Đây là một trick giảm độ phức tạp để xử lí offline truy vấn những đỉnh trên cây. Ý tưởng chính là lưu thông tin của cây con to nhất và chỉ reset các thông tin của cây con nhỏ hơn. Độ phức tạp duyệt thường là $$O(n \log(n))$$, khi kết hợp các cấu trúc dữ liệu thì ta được $$O(n \log^2(n))$$.

Trở lại với bài toán, gọi $$h[i]$$ là độ sâu của cây con gốc $$i$$. Ta quy mảng $$cnt[u][i]$$ về mảng $$h$$. Để tìm nhanh chỉ số, ta có thể dùng segment tree.

[code](https://ideone.com/0bNtAM).

ĐPT: $$O(n \log^2(n))$$. Thực tế có thể chạy nhanh hơn.