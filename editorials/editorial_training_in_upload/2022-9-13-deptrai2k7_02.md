---
layout: post
published: true
title: deptrai2k7 02
date: 2022/09/13
tags: [CP]
---

## ICPC

#### subtask 1:

Ta duyệt hai vị trí $$0 \le i < j \le n + 1$$ với ý nghĩa Việt làm các bài từ $$1$$ đến $$i$$ và Lợi làm các bài từ $$j$$ đến $$n + 1$$. Từ đó dễ dàng tính được độ khó của hai bạn.

ĐPT: $$O(n^3)$$.

#### subtask 2:

Bước tính ở subtask $$1$$ tốn thời gian $$O(n)$$ nên ta cần loại bỏ nó. Chuẩn bị trước hai mảng prefix xor và suffix xor để tính độ khó của hai bạn nhanh.

ĐPT: $$O(n^2)$$.

#### subtask 3:

Với mỗi $$i$$, ta cần tìm $$j > i$$ sao cho $$prefxor[i] \oplus suffxor[i]$$ lớn nhất và lấy max các kết quả. Do đó ta nghĩ đến việc sử dụng trie. 

ĐPT: $$O(n \times 40)$$.

[code](https://ideone.com/0dRBZ3).

## Tán gái

#### subtask 1: 

Ta duyệt qua đường đi giữa $$u$$ và $$v$$ để đếm.

ĐPT: $$O(n \times d)$$.

#### subtask 2:

$$u \times v + 1 = u + v$$.

$$(u - 1) \times (v - 1) = 0$$.

$$u = 1$$ or $$v = 1$$.

Không mất tính tổng quát, giả sử $$u = 1$$. Ta coi $$1$$ là gốc của cây. Ta cần chuẩn bị mảng đáp án $$ans[u]$$ trên đường đi từ gốc tới một node $$u$$ bất kì. Giả sử đỉnh $$v$$ có con là $$u$$, vậy $$ans[u] = ans[v] + X$$. Ta duy trì một mảng `cnt_food` và `cnt_girl` khi duyệt `dfs` để tính $$X$$.

ĐPT: $$O(n)$$.

#### subtask 3:

Cây lúc này có dạng đường thẳng. Do vậy ta có thể dùng thuật toán `mo` để xét và duy trì các đường đi giữa hai đỉnh truy vấn. Khi thêm hoặc khi xoá một đỉnh mới, ta biết được đáp số tăng giảm nhờ duy trì hai mảng $$cnt$$ nhu subtask $$2$$.

ĐPT: $$O((n + q) \times \sqrt{n})$$.

#### subtask 4:

Dùng thuật toán [mo on tree](https://codeforces.com/blog/entry/43230) để đưa về subtask $$3$$. Chú ý là vẫn có sự khác biệt với mo thông thường.

ĐPT: $$O((n + q) \times \sqrt{n})$$.

[code](https://ideone.com/hCnP2p).

## Sắp xếp

#### subtask 1:

Chọn ra thay gươm và vị trí thay đổi. Sau đó tính độ đẹp và lấy max.

ĐPT: $$O(n^3)$$.

#### subtask 2:

Giả sử thanh gươm ban đầu ở vị trí $$i$$, ta thay đổi nó sang vị trí $$j$$.

Xét $$i < j$$. Tất cả các thanh gươm có vị trí từ $$i + 1$$ đến $$j$$ sẽ bị dịch sang trái một vị trí. Các thanh gươm còn lại giữ nguyên vị trí. Gọi $$f(u, v)$$ là tổng độ sắc bén các thanh gươm trong đoạn $$[u, v]$$. Gọi $$g(u, v)$$ là tổng độ đẹp nếu các thanh gươm trong đoạn $$[u, v]$$ giữ nguyên vị trí. Lúc này ta có được độ đẹp mới là $$A = g(1, n) - f(i + 1, j) + a_i \times (j - i)$$.

Xét $$i > j$$ tương tự.

ĐPT: $$O(n^2)$$.

#### subtask 3:

Ta tách A ra.

$$A = g(1, n) - (f(1, j) - f(1, i)) + (a_i \times j - a_i \times i))$$.

$$A = (g(1, n) - a_i \times i + f(1, i)) + (a_i \times j - f(1, j))$$.

Ta thấy phần đầu tiên không thay đổi nếu cố định $$i$$. 

Do đó ta cần tìm $$j > i$$ sao cho $$B(a(i)) = a_i \times j - f(1, j)$$ lớn nhất.

Khi duyệt $$i$$ từ $$n$$ về, sau bước tính toán, ta update tất cả $$B(x)$$ với $$-123 \le x \le 123$$.    

ĐPT: $$O(n \times 123)$$.

#### subtask 4:

Vì B có dạng đường thẳng nên có thể dùng Lichao Tree hoặc Line Container để tìm $$j$$ nhanh hơn.

ĐPT: $$O(n \times log(n))$$.                                                                                                                                   
[code](https://ideone.com/qnYKKr).